name: Actions Runner Controller Demo
on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/test-app

jobs:
  test-arc-functionality:
    runs-on: kubelab-runner-set
    permissions:
      contents: read
      packages: write
    steps:
    - name: üéâ Welcome message
      run: echo "üéâ This job uses runner scale set runners!"
      
    - name: üîç Explore runner environment
      run: |
        echo "üñ•Ô∏è The job was automatically triggered by a ${{ github.event_name }} event."
        echo "üêß This job is now running on a ${{ runner.os }} server hosted by GitHub!"
        echo "üîé The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
        echo "üí° Runner name: ${{ runner.name }}"
        echo "üè† Runner workspace: ${{ runner.workspace }}"
        
    - name: üìã System information
      run: |
        echo "=== System Information ==="
        uname -a
        echo "=== CPU Information ==="
        nproc
        echo "=== Memory Information ==="
        free -h
        echo "=== Disk Space ==="
        df -h
        
    - name: üõí Check out repository code
      uses: actions/checkout@v4

  test-docker-functionality:
    runs-on: kubelab-runner-set
    # if: false  # Temporarily disabled until Docker-in-Docker is configured
    needs: test-arc-functionality
    env:
      DOCKER_HOST: tcp://localhost:2376
      DOCKER_TLS_CERTDIR: ""
      DOCKER_TLS_VERIFY: ""
    steps:
    - name: üõí Check out repository code
      uses: actions/checkout@v4
      
    - name: ‚è≥ Wait for Docker daemon to be ready
      env:
        DOCKER_HOST: tcp://localhost:2376
        DOCKER_TLS_CERTDIR: ""
        DOCKER_TLS_VERIFY: ""
      run: |
        echo "Waiting for Docker daemon to start..."
        echo "Docker host: $DOCKER_HOST"
        echo "TLS disabled: DOCKER_TLS_CERTDIR='$DOCKER_TLS_CERTDIR'"
        timeout=30
        while [ $timeout -gt 0 ]; do
          echo "Checking Docker daemon connectivity..."
          if docker version >/dev/null 2>&1; then
            echo "‚úÖ Docker daemon is ready!"
            docker version
            break
          fi
          echo "Waiting for Docker daemon... ($timeout seconds remaining)"
          sleep 2
          timeout=$((timeout-2))
        done
        if [ $timeout -le 0 ]; then
          echo "‚ùå Docker daemon failed to start within 30 seconds"
          echo "Debugging information:"
          echo "DOCKER_HOST: $DOCKER_HOST"
          echo "DOCKER_TLS_CERTDIR: '$DOCKER_TLS_CERTDIR'"
          echo "DOCKER_TLS_VERIFY: '$DOCKER_TLS_VERIFY'"
          echo "Checking if Docker binary exists:"
          which docker || echo "Docker binary not found"
          echo "Checking Docker binary version:"
          docker --version || echo "Cannot get Docker version"
          echo "Checking processes:"
          ps aux | grep docker || echo "No docker processes found"
          exit 1
        fi
        
    - name: üê≥ Test Docker version and info
      run: |
        echo "=== Docker Version ==="
        docker --version
        echo "=== Docker Info ==="
        docker info
        echo "=== Docker System Info ==="
        docker system info --format "{{.ServerVersion}}"
        
    - name: üß™ Test Docker run commands
      run: |
        echo "=== Testing Docker Run Commands ==="
        
        echo "1. Running hello-world container..."
        docker run --rm hello-world
        
        echo "2. Running Alpine Linux with basic commands..."
        docker run --rm alpine:latest echo "Hello from Alpine!"
        
        echo "3. Running Ubuntu with system info..."
        docker run --rm ubuntu:latest bash -c "echo 'Ubuntu container:' && uname -a && cat /etc/os-release | head -5"
        
        echo "4. Testing volume mounts..."
        docker run --rm -v /tmp:/host-tmp alpine:latest sh -c "echo 'Test file from container' > /host-tmp/test.txt && cat /host-tmp/test.txt"
        
        echo "5. Testing environment variables..."
        docker run --rm -e TEST_VAR="Hello from Docker" alpine:latest sh -c "echo 'Environment variable: $TEST_VAR'"
        
    - name: üìù Create test application files
      run: |
        echo "=== Creating Test Application ==="
        
        # Create a simple Node.js application
        cat > app.js << 'EOF'
        const http = require('http');
        const os = require('os');
        
        const server = http.createServer((req, res) => {
          const response = {
            message: 'Hello from ARC Runner Docker Container!',
            hostname: os.hostname(),
            platform: os.platform(),
            arch: os.arch(),
            uptime: os.uptime(),
            timestamp: new Date().toISOString(),
            path: req.url
          };
          
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(response, null, 2));
        });
        
        const port = process.env.PORT || 3000;
        server.listen(port, () => {
          console.log(`Server running on port ${port}`);
          console.log(`Hostname: ${os.hostname()}`);
          console.log(`Platform: ${os.platform()}`);
        });
        EOF
        
        # Create package.json
        cat > package.json << 'EOF'
        {
          "name": "arc-test-app",
          "version": "1.0.0",
          "description": "Test application for ARC Docker functionality",
          "main": "app.js",
          "scripts": {
            "start": "node app.js"
          },
          "dependencies": {},
          "engines": {
            "node": ">=14"
          }
        }
        EOF
        
        # Create Dockerfile
        cat > Dockerfile << 'EOF'
        FROM node:18-alpine
        
        # Set working directory
        WORKDIR /app
        
        # Copy package files
        COPY package*.json ./
        
        # Install dependencies (none in this case, but good practice)
        RUN npm install --only=production
        
        # Copy application code
        COPY app.js .
        
        # Create non-root user
        RUN addgroup -g 1001 -S nodejs && \
            adduser -S nodejs -u 1001
        
        # Change ownership of the app directory
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        
        # Expose port
        EXPOSE 3000
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
          CMD curl -f http://localhost:3000/ || exit 1
        
        # Start the application
        CMD ["npm", "start"]
        EOF
        
        # Create .dockerignore
        cat > .dockerignore << 'EOF'
        node_modules
        npm-debug.log
        .git
        .gitignore
        README.md
        .env
        .nyc_output
        coverage
        .nyc_output
        EOF
        
        echo "‚úÖ Application files created successfully!"
        ls -la
        
    - name: üî® Test Docker build commands
      run: |
        echo "=== Testing Docker Build Commands ==="
        
        echo "1. Building the test application image..."
        docker build -t arc-test-app:latest .
        
        echo "2. Building with custom tag..."
        docker build -t arc-test-app:${{ github.sha }} .
        
        echo "3. Building with build arguments..."
        docker build --build-arg NODE_ENV=production -t arc-test-app:prod .
        
        echo "4. Listing built images..."
        docker images | grep arc-test-app
        
        echo "5. Inspecting the built image..."
        docker inspect arc-test-app:latest | jq '.[0].Config.ExposedPorts, .[0].Config.Cmd'
        
    - name: üöÄ Test running the built application
      run: |
        echo "=== Testing Built Application ==="
        
        echo "1. Running the application container in background..."
        docker run -d --name test-app -p 3000:3000 arc-test-app:latest
        
        echo "2. Waiting for application to start..."
        sleep 5
        
        echo "3. Testing application endpoint..."
        # Try different methods to test the endpoint
        if docker exec test-app which curl >/dev/null 2>&1; then
          response=$(docker exec test-app curl -s http://localhost:3000/ || echo "curl failed")
        elif docker exec test-app which wget >/dev/null 2>&1; then
          response=$(docker exec test-app wget -qO- http://localhost:3000/ || echo "wget failed")
        else
          # Test from host using container's port mapping
          response=$(curl -s http://localhost:3000/ || echo "host curl failed")
        fi
        
        echo "Raw response: $response"
        if echo "$response" | jq . >/dev/null 2>&1; then
          echo "‚úÖ Valid JSON response:"
          echo "$response" | jq .
        else
          echo "‚ö†Ô∏è  Response is not valid JSON, showing raw output:"
          echo "$response"
        fi
        
        echo "4. Checking container logs..."
        docker logs test-app
        
        echo "5. Checking container stats..."
        docker stats test-app --no-stream
        
        echo "6. Stopping and removing container..."
        docker stop test-app
        docker rm test-app
        
    - name: üè∑Ô∏è Test Docker tagging and registry operations
      run: |
        echo "=== Testing Docker Tagging ==="
        
        echo "1. Tagging for registry..."
        docker tag arc-test-app:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker tag arc-test-app:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        echo "2. Listing all tagged images..."
        docker images | grep -E "(arc-test-app|${{ env.IMAGE_NAME }})"
        
    - name: üîê Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üì§ Test Docker push to registry
      if: github.event_name != 'pull_request'
      continue-on-error: true
      run: |
        echo "=== Testing Docker Push ==="
        
        echo "1. Attempting to push image with SHA tag..."
        if docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}; then
          echo "‚úÖ SHA tag push successful!"
        else
          echo "‚ö†Ô∏è  SHA tag push failed (this may be due to permissions)"
        fi
        
        echo "2. Attempting to push image with latest tag..."
        if docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest; then
          echo "‚úÖ Latest tag push successful!"
        else
          echo "‚ö†Ô∏è  Latest tag push failed (this may be due to permissions)"
        fi
        
        echo "‚ÑπÔ∏è  Registry push test completed (failures are non-critical for testing)"
        
    - name: üß™ Test Docker multi-stage builds
      run: |
        echo "=== Testing Multi-stage Docker Build ==="
        
        # Create multi-stage Dockerfile
        cat > Dockerfile.multistage << 'EOF'
        # Build stage
        FROM node:18-alpine AS builder
        WORKDIR /app
        COPY package*.json ./
        RUN npm install
        COPY app.js .
        
        # Production stage
        FROM node:18-alpine AS production
        WORKDIR /app
        RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
        COPY --from=builder /app .
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        EXPOSE 3000
        CMD ["node", "app.js"]
        EOF
        
        echo "Building multi-stage image..."
        docker build -f Dockerfile.multistage -t arc-test-app:multistage .
        
        echo "Comparing image sizes..."
        docker images | grep arc-test-app
        
    - name: üßπ Test Docker cleanup commands
      run: |
        echo "=== Testing Docker Cleanup ==="
        
        echo "1. Current Docker usage..."
        docker system df
        
        echo "2. Removing unused images..."
        docker image prune -f
        
        echo "3. Removing all test images..."
        docker rmi $(docker images "arc-test-app" -q) || true
        docker rmi $(docker images "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" -q) || true
        
        echo "4. Final cleanup..."
        docker system prune -f
        
        echo "5. Final Docker usage..."
        docker system df
        
    - name: ‚úÖ Docker functionality summary
      run: |
        echo "üéâ Docker Functionality Test Summary:"
        echo "‚úÖ Docker daemon connectivity"
        echo "‚úÖ Docker run commands with various options"
        echo "‚úÖ Docker build with Dockerfile"
        echo "‚úÖ Docker build with build arguments"
        echo "‚úÖ Docker multi-stage builds"
        echo "‚úÖ Container execution and interaction"
        echo "‚úÖ Docker tagging and registry operations"
        echo "‚úÖ Docker push to GitHub Container Registry"
        echo "‚úÖ Docker cleanup and system management"
        echo "üöÄ ARC Runner with Docker-in-Docker is fully functional!"
