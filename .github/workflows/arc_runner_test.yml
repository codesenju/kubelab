name: Actions Runner Controller Demo
on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/test-app

jobs:
  test-arc-functionality:
    runs-on: kubelab-runner-set
    permissions:
      contents: read
      packages: write
    steps:
    - name: ðŸŽ‰ Welcome message
      run: echo "ðŸŽ‰ This job uses runner scale set runners!"
      
    - name: ðŸ” Explore runner environment
      run: |
        echo "ðŸ–¥ï¸ The job was automatically triggered by a ${{ github.event_name }} event."
        echo "ðŸ§ This job is now running on a ${{ runner.os }} server hosted by GitHub!"
        echo "ðŸ”Ž The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
        echo "ðŸ’¡ Runner name: ${{ runner.name }}"
        echo "ðŸ  Runner workspace: ${{ runner.workspace }}"
        
    - name: ðŸ“‹ System information
      run: |
        echo "=== System Information ==="
        uname -a
        echo "=== CPU Information ==="
        nproc
        echo "=== Memory Information ==="
        free -h
        echo "=== Disk Space ==="
        df -h
        
    - name: ðŸ›’ Check out repository code
      uses: actions/checkout@v4

  test-docker-functionality:
    runs-on: kubelab-runner-set
    needs: test-arc-functionality
    steps:
    - name: ðŸ›’ Check out repository code
      uses: actions/checkout@v4
      
    - name: â³ Detect and configure Docker daemon
      run: |
        echo "=== Detecting Docker configuration ==="
        
        # Try different Docker hosts until one works
        for host in "" "tcp://localhost:2375" "tcp://localhost:2376" "unix:///var/run/docker.sock"; do
          if [ -n "$host" ]; then
            echo "Testing Docker host: $host"
            export DOCKER_HOST=$host
            
            # Disable TLS verification for TCP connections
            if [[ $host == tcp://* ]]; then
              export DOCKER_TLS_VERIFY=""
              export DOCKER_CERT_PATH=""
              export DOCKER_TLS_CERTDIR=""
            fi
          else
            echo "Testing with default Docker configuration"
            unset DOCKER_HOST DOCKER_TLS_VERIFY DOCKER_CERT_PATH DOCKER_TLS_CERTDIR
          fi
          
          if docker version >/dev/null 2>&1; then
            echo "âœ… Docker is working with configuration:"
            echo "  DOCKER_HOST: ${DOCKER_HOST:-default}"
            echo "  DOCKER_TLS_VERIFY: ${DOCKER_TLS_VERIFY:-default}"
            docker version
            
            # Export the working configuration for subsequent steps
            echo "DOCKER_HOST=${DOCKER_HOST:-}" >> $GITHUB_ENV
            echo "DOCKER_TLS_VERIFY=${DOCKER_TLS_VERIFY:-}" >> $GITHUB_ENV
            echo "DOCKER_TLS_CERTDIR=${DOCKER_TLS_CERTDIR:-}" >> $GITHUB_ENV
            break
          else
            echo "âŒ Docker failed with this configuration"
          fi
        done
        
        # Final verification
        if ! docker version >/dev/null 2>&1; then
          echo "âŒ Docker is not working with any configuration"
          echo "Debugging information:"
          echo "Available Docker hosts checked: default, tcp://localhost:2375, tcp://localhost:2376, unix:///var/run/docker.sock"
          echo "Docker binary: $(which docker)"
          echo "Docker version: $(docker --version)"
          echo "Processes: $(ps aux | grep docker || echo 'No docker processes')"
          exit 1
        fi
        
    - name: ðŸ³ Test Docker version and info
      run: |
        echo "=== Docker Version ==="
        docker --version
        echo "=== Docker Info ==="
        docker info
        echo "=== Docker System Info ==="
        docker system info --format "{{.ServerVersion}}"
        
    - name: ðŸ§ª Test Docker run commands
      run: |
        echo "=== Testing Docker Run Commands ==="
        
        echo "1. Running hello-world container..."
        docker run --rm hello-world
        
        echo "2. Running Alpine Linux with basic commands..."
        docker run --rm alpine:latest echo "Hello from Alpine!"
        
        echo "3. Running Ubuntu with system info..."
        docker run --rm ubuntu:latest bash -c "echo 'Ubuntu container:' && uname -a && cat /etc/os-release | head -5"
        
        echo "4. Testing volume mounts..."
        docker run --rm -v /tmp:/host-tmp alpine:latest sh -c "echo 'Test file from container' > /host-tmp/test.txt && cat /host-tmp/test.txt"
        
        echo "5. Testing environment variables..."
        docker run --rm -e TEST_VAR="Hello from Docker" alpine:latest sh -c "echo 'Environment variable: $TEST_VAR'"
        
    - name: ðŸ“ Create test application files
      run: |
        echo "=== Creating Test Application ==="
        
        # Create a simple Node.js application
        cat > app.js << 'EOF'
        const http = require('http');
        const os = require('os');
        
        const server = http.createServer((req, res) => {
          const response = {
            message: 'Hello from ARC Runner Docker Container!',
            hostname: os.hostname(),
            platform: os.platform(),
            arch: os.arch(),
            uptime: os.uptime(),
            timestamp: new Date().toISOString(),
            path: req.url
          };
          
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(response, null, 2));
        });
        
        const port = process.env.PORT || 3000;
        server.listen(port, () => {
          console.log(`Server running on port ${port}`);
          console.log(`Hostname: ${os.hostname()}`);
          console.log(`Platform: ${os.platform()}`);
        });
        EOF
        
        # Create package.json
        cat > package.json << 'EOF'
        {
          "name": "arc-test-app",
          "version": "1.0.0",
          "description": "Test application for ARC Docker functionality",
          "main": "app.js",
          "scripts": {
            "start": "node app.js"
          },
          "dependencies": {},
          "engines": {
            "node": ">=14"
          }
        }
        EOF
        
        # Create Dockerfile
        cat > Dockerfile << 'EOF'
        FROM node:18-alpine
        
        # Set working directory
        WORKDIR /app
        
        # Copy package files
        COPY package*.json ./
        
        # Install dependencies (none in this case, but good practice)
        RUN npm install --only=production
        
        # Copy application code
        COPY app.js .
        
        # Create non-root user
        RUN addgroup -g 1001 -S nodejs && \
            adduser -S nodejs -u 1001
        
        # Change ownership of the app directory
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        
        # Expose port
        EXPOSE 3000
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
          CMD curl -f http://localhost:3000/ || exit 1
        
        # Start the application
        CMD ["npm", "start"]
        EOF
        
        # Create .dockerignore
        cat > .dockerignore << 'EOF'
        node_modules
        npm-debug.log
        .git
        .gitignore
        README.md
        .env
        .nyc_output
        coverage
        .nyc_output
        EOF
        
        echo "âœ… Application files created successfully!"
        ls -la
        
    - name: ðŸ”¨ Test Docker build commands
      run: |
        echo "=== Testing Docker Build Commands ==="
        
        echo "1. Building the test application image..."
        docker build -t arc-test-app:latest .
        
        echo "2. Building with custom tag..."
        docker build -t arc-test-app:${{ github.sha }} .
        
        echo "3. Building with build arguments..."
        docker build --build-arg NODE_ENV=production -t arc-test-app:prod .
        
        echo "4. Listing built images..."
        docker images | grep arc-test-app
        
        echo "5. Inspecting the built image..."
        docker inspect arc-test-app:latest | jq '.[0].Config.ExposedPorts, .[0].Config.Cmd'
        
    - name: ðŸš€ Test running the built application
      run: |
        echo "=== Testing Built Application ==="
        
        echo "1. Running the application container in background..."
        docker run -d --name test-app -p 3000:3000 arc-test-app:latest
        
        echo "2. Waiting for application to start..."
        sleep 5
        
        echo "3. Testing application endpoint..."
        # Try different methods to test the endpoint
        if docker exec test-app which curl >/dev/null 2>&1; then
          response=$(docker exec test-app curl -s http://localhost:3000/ || echo "curl failed")
        elif docker exec test-app which wget >/dev/null 2>&1; then
          response=$(docker exec test-app wget -qO- http://localhost:3000/ || echo "wget failed")
        else
          # Test from host using container's port mapping
          response=$(curl -s http://localhost:3000/ || echo "host curl failed")
        fi
        
        echo "Raw response: $response"
        if echo "$response" | jq . >/dev/null 2>&1; then
          echo "âœ… Valid JSON response:"
          echo "$response" | jq .
        else
          echo "âš ï¸  Response is not valid JSON, showing raw output:"
          echo "$response"
        fi
        
        echo "4. Checking container logs..."
        docker logs test-app
        
        echo "5. Checking container stats..."
        docker stats test-app --no-stream
        
        echo "6. Stopping and removing container..."
        docker stop test-app
        docker rm test-app
        
    - name: ðŸ·ï¸ Test Docker tagging and registry operations
      run: |
        echo "=== Testing Docker Tagging ==="
        
        echo "1. Tagging for registry..."
        docker tag arc-test-app:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker tag arc-test-app:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        echo "2. Listing all tagged images..."
        docker images | grep -E "(arc-test-app|${{ env.IMAGE_NAME }})"
        
    - name: ðŸ” Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: ðŸ“¤ Test Docker push to registry
      if: github.event_name != 'pull_request'
      continue-on-error: true
      run: |
        echo "=== Testing Docker Push ==="
        
        echo "1. Attempting to push image with SHA tag..."
        if docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}; then
          echo "âœ… SHA tag push successful!"
        else
          echo "âš ï¸  SHA tag push failed (this may be due to permissions)"
        fi
        
        echo "2. Attempting to push image with latest tag..."
        if docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest; then
          echo "âœ… Latest tag push successful!"
        else
          echo "âš ï¸  Latest tag push failed (this may be due to permissions)"
        fi
        
        echo "â„¹ï¸  Registry push test completed (failures are non-critical for testing)"
        
    - name: ðŸ§ª Test Docker multi-stage builds
      run: |
        echo "=== Testing Multi-stage Docker Build ==="
        
        # Create multi-stage Dockerfile
        cat > Dockerfile.multistage << 'EOF'
        # Build stage
        FROM node:18-alpine AS builder
        WORKDIR /app
        COPY package*.json ./
        RUN npm install
        COPY app.js .
        
        # Production stage
        FROM node:18-alpine AS production
        WORKDIR /app
        RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
        COPY --from=builder /app .
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        EXPOSE 3000
        CMD ["node", "app.js"]
        EOF
        
        echo "Building multi-stage image..."
        docker build -f Dockerfile.multistage -t arc-test-app:multistage .
        
        echo "Comparing image sizes..."
        docker images | grep arc-test-app
        
    - name: ðŸ§¹ Test Docker cleanup commands
      run: |
        echo "=== Testing Docker Cleanup ==="
        
        echo "1. Current Docker usage..."
        docker system df
        
        echo "2. Removing unused images..."
        docker image prune -f
        
        echo "3. Removing all test images..."
        docker rmi $(docker images "arc-test-app" -q) || true
        docker rmi $(docker images "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" -q) || true
        
        echo "4. Final cleanup..."
        docker system prune -f
        
        echo "5. Final Docker usage..."
        docker system df
        
    - name: âœ… Docker functionality summary
      run: |
        echo "ðŸŽ‰ Docker Functionality Test Summary:"
        echo "âœ… Docker daemon connectivity"
        echo "âœ… Docker run commands with various options"
        echo "âœ… Docker build with Dockerfile"
        echo "âœ… Docker build with build arguments"
        echo "âœ… Docker multi-stage builds"
        echo "âœ… Container execution and interaction"
        echo "âœ… Docker tagging and registry operations"
        echo "âœ… Docker push to GitHub Container Registry"
        echo "âœ… Docker cleanup and system management"
        echo "ðŸš€ ARC Runner with Docker-in-Docker is fully functional!"
